#include <iostream>
#include <list>
#include "Elevator.h"

using namespace std;

Elevator::Elevator() {

}

Elevator::Elevator(int init_floor, elevator_direction cur_direction) {
	initial_floor = init_floor;
	current_direction = cur_direction;
	current_load = 0;
}

Elevator::~Elevator() {

}

int Elevator::getCurrentLoad() {
	return current_load;
}

float Elevator::getCurrentFloor() {
	return current_floor;
}

elevator_state& Elevator::getCurrentState() {
	return current_state;
}

elevator_direction& Elevator::getCurrentDirection() {
	return current_direction;
}

void Elevator::setCurrentDirection(elevator_direction direction)_ {
	current_direction = direction;
}

void Elevator::takePassengers(int num_of_passengers) {
	current_load += num_of_passengers;
}

void Elevator::removePassengers(int num_of_passengers) {
	current_load -= num_of_passengers;
}

list<Passenger>& Elevator::getPassengers() {
	return passengers;
}

void Elevator::update() {
	if(current_direction == UP) {
		if(current_floor > 100.0) {
			current_floor -= 0.1;
			current_direction = DOWN;
		}
		else {
			current_floor += 0.1;
		}
	}
	else {
		if(current_floor < 0.0) {
			current_floor += 0.1;
			current_direction = UP;
		}
		else {
			current_floor -= 0.1;
		}
	}

	//Iterate list of passengers
	list<Passenger>::iterator passengers_it;
	for(passengers_it= passengers.begin(); passengers_it != passengers.end(); ++passengers_it) {
		cout << passengers_it->getDestinationFloor() << endl;

		passengers_it->addTravelTime(1);
	}
}

#ifndef __ELEVATOR_ENUM__
#define __ELEVATOR_ENUM__

enum elevator_state {STOPPED, STOPPING, MOVING_UP, MOVING_DOWN};
enum elevator_direction {UP, DOWN};
enum passenger_state {WAITING, RIDING, ARRIVED};

#endif
#ifndef __ELEVATOR_H__
#define __ELEVATOR_H__

#include <list>
#include "Passenger.h"
#include "ElevatorEnum.h"
#include "Updateable.h"

using namespace std;

class Elevator : public Updateable {

public:

	Elevator();
	Elevator(int, elevator_direction);
	~Elevator();

	static const int MAX_LOAD = 8;

	int getCurrentLoad();
	float getCurrentFloor();
	elevator_state& getCurrentState();
	elevator_direction& getCurrentDirection();

	void setCurrentDirection(elevator_direction);
	void takePassengers(int num_of_passengers = 1);
	void removePassengers(int num_of_passengers = 1);
	list<Passenger>& getPassengers();
	void update();

private:
	int current_load;
	float current_floor;
	elevator_state current_state;

	list<Passenger> passengers;

	int initial_floor;
	elevator_direction current_direction;

	static const float travel_speed = 1.0 / 10.0;

};

#endif


#include "Floor.h"

Floor::Floor() {


}

Floor::~Floor() {

}

queue<Passenger>& Floor::getPassengers() {
	return passengers;
}

void Floor::addPAssenger(Passenger& p) {
	passengers.push(p);
}

void Floor::update() {

}

#ifndef __FLOOR_H__
#define __FLOOR_H__

#include <queue>
#include "Updateable.h"
#include "Passenger.h"

using namespace std;

class Floor : public Updateable {

public:

	Floor();
	~Floor();

	void update();

	queue<Passenger>& getPassengers();
	void addPassenger(Passenger&);

private:
	queue<Passenger> passengers;

};


#endif



#include "Passenger.h"


Passenger::Passenger(int value) {
	destination_floor = value;
}

Passenger::~Passenger() {

}

void Passenger::addWaitTime(int wt) {
	wait_time = wt;
}

int& Passenger::getWaitTime() {
	return wait_time;
}

int& Passenger::getTravelTime() {
	return travel_time;
}

void Passenger::addTravelTime(int tt) {
	travel_time = tt;
}

void Passenger::update() {

}

int& Passenger::getDestinationFloor() {
	return destination_floor;
}


#ifndef __PASSENGER_H__
#define __PASSENGER_H__

#include "Updateable.h"

using namespace std;

class Passenger : public Updateable {

public:

	//Construct passenger with destination floor
	Passenger(int);
	~Passenger();

	int& getWaitTime();
	void addWaitTime(int);
	int& getTravelTime();
	void addTraveltime(int;)
	void update();
	void startTravelTime();
	void startWaitTime();
	int& getDestinationFloor();

private:

	int wait_time;
	int travel_time;
	int destination_floor;
};

#endif


#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <list>
#include <map>
#include <queue>
#include <cmath>
#include <vector>

#include "ElevatorEnum.h"
#include "Elevator.h"
#incldue "Passenger.h"
#include "Floor.h"

using namespace std;

map<int, map<string, int>> getData() {
	map<int, map<string, int>> records;

	ifstream infile("data.csv");

	while(infile) {
		string s;
		if(!getline(infile, s)) {
			break;
		}


		istringstream ss(s);

		int start_time;
		int start_floor;
		int end_floor;
		int value;
		int index = 0;
		while(ss >> value) {
			switch(index) {
			case 0: start_time = value;
					break;
			case 1: start_floor = value;
					break;
			case 2: end_floor = value;
					break;
			}

			if(ss.peek() == ',') {
				ss.ignore();
			}

			index++;
		}

		map<string, int> record;

		record["start_floor"] = start_floor;
		record["end_floor"] = end_floor;
		record[start_time] = record;
	}

	return records;

}

int main() {
	vector<Floor> floors;
	for(int floor_number = 0; floor_number < 100; floor_number++) {
		floors.push_back(Floor());
	}

	list<int> wait_times;
	list<int> travel_times;

	map<int, queue<Passenger>> building;

	map<int, map<string, int>> records = getData();

	/*
	// For debugging only
	for (map<int, map<string,int>>::iterator o_it = records.begin(); o_it != records.end(); ++o_it) {
		cout << o_it->first << endl;

		cout << o_it->second["start_floor"] << " - " << o_it->second["end_floor"] << endl;

		for (map<string, int>::iterator i_it = o_it->second.begin(); i_it != o_it->second.end(); ++i_it) {
			cout << i_it->first << " - " << i_it->second << endl;
		}
	}
	*/

	// Initialize all four elevators
	list<Elevator> elevators;

	Elevator e1(0, UP);
	Elevator e2(100, DOWN);
	Elevator e3(25, UP);
	Elevator e4(75, DOWN);

	elevators.push_front(e1);
	elevators.push_front(e2);
	elevators.push_front(e3);
	elevators.push_front(e4);

	// Start simulation
	for(int start_time = 0; start_time < 15216; start_time++) {

		map<int, map<string, int>>::iterator records_it = records.find(start_time);

		if(records_it != records.end()) {

			//Found start time
			// Create passenger waiting at start floor
			int start_floor = records_it->second["start_floor"];
			int end_floor = records_it->second["end_floor"];
			Passenger p(end_floor);

			floors[start_floor].addPassenger(p);
		}

		// Update each elevator
		for(list<Elevator>::iterator it = elevators.begin(); it != elevators.end(); ++it) {
			it->update();
//			cout << j << " : " << floor(it->getCurrentFloor()) << endl;
		}

		// Update each floor
		for(vector<Floor>::iterator it = floors.begin(); it != floors.end(); ++it) {

		}


	}
	/*
	for(int start_time = 0; start_time < 15216; start_time++) {
		map<int, map<string, int>> ::iterator records_it = records.find(start_time);
		if (records_it != records.end()) {
			cout << start_time << endl;
		}
	}

*/

	return 0;

}

