//============================================================================
// Name        : Module8_ExpressionTree.cpp
// Author      : 
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <sstream>
using namespace std;

class Node {

public:

	virtual double evaluate() = 0;
};

class Constant: public Node {

	double number;

public:

	Constant(double value) {
		number = value;

	}

	double evaluate() {
		return number;
	}

};

class Variable: public Node {

	double number;
	string variable;

public:

	Variable(double value) {
		number = value;
	}

	Variable(string const& v) : variable(v) {

	}

	double evaluate() {
		return number;
	}

	string getVariable() {
		return variable;
	}
};

class Tree : public Node {

protected:

	Node *leftNode;
	Node *rightNode;
};

class Add : public Tree {

public:

	Add(Node *leftNode, Node *rightNode) {
		this -> leftNode = leftNode;
		this -> rightNode = rightNode;
	}

	double evaluate() {
		double leftNodeValue = leftNode -> evaluate();
		double rightNodeValue = rightNode -> evaluate();

		return leftNodeValue + rightNodeValue;
	}

	friend ostream& operator<<(ostream& os, const Add& add);

	string getExpression() const {
		ostringstream lstrs;
		lstrs << leftNode -> evaluate();
		string leftStr = lstrs.str();

		ostringstream rstrs;
		rstrs << rightNode -> evaluate();
		string rightStr = rstrs.str();

		return "(" + leftStr + " + " + rightStr + ")";
	}
};

ostream& operator<<(ostream& os, const Add& add) {
	os << add.getExpression();
	return os;
}

class Sub : public Tree {

public:

	Sub(Node *leftNode, Node *rightNode) {
		this -> leftNode = leftNode;
		this -> rightNode = rightNode;
	}

	double evaluate() {
		double leftNodeValue = leftNode -> evaluate();
		double rightNodeValue = rightNode -> evaluate();

		return leftNodeValue - rightNodeValue;
	}

	friend ostream& operator<<(ostream& os, const Sub& sub);

		string getExpression() const {
			ostringstream lstrs;
			lstrs << leftNode -> evaluate();
			string leftStr = lstrs.str();

			ostringstream rstrs;
			rstrs << rightNode -> evaluate();
			string rightStr = rstrs.str();

			return "(" + leftStr + " - " + rightStr + ")";
		}
};

ostream& operator<<(ostream& os, const Sub& sub) {
	os << sub.getExpression();
	return os;
}

class Mul : public Tree {

public:

	Mul(Node *leftNode, Node *rightNode) {
		this -> leftNode = leftNode;
		this -> rightNode = rightNode;
	}

	double evaluate() {
		double leftNodeValue = leftNode -> evaluate();
		double rightNodeValue = rightNode -> evaluate();

		return leftNodeValue * rightNodeValue;
	}

	friend ostream& operator<<(ostream& os, const Mul& mul);

			string getExpression() const {
				ostringstream lstrs;
				lstrs << leftNode -> evaluate();
				string leftStr = lstrs.str();

				ostringstream rstrs;
				rstrs << rightNode -> evaluate();
				string rightStr = rstrs.str();

				return "(" + leftStr + " * " + rightStr + ")";
			}
};

ostream& operator<<(ostream& os, const Mul& mul) {
	os << mul.getExpression();
	return os;
}

class Div : public Tree {

public:

	Div(Node *leftNode, Node *rightNode) {
		this -> leftNode = leftNode;
		this -> rightNode = rightNode;
	}

	double evaluate() {
		double leftNodeValue = leftNode -> evaluate();
		double rightNodeValue = rightNode -> evaluate();

		return leftNodeValue / rightNodeValue;
	}

	friend ostream& operator<<(ostream& os, const Div& div);

			string getExpression() const {
				ostringstream lstrs;
				lstrs << leftNode -> evaluate();
				string leftStr = lstrs.str();

				ostringstream rstrs;
				rstrs << rightNode -> evaluate();
				string rightStr = rstrs.str();

				return "(" + leftStr + " / " + rightStr + ")";
			}
};

ostream& operator<<(ostream& os, const Div& div) {
	os << div.getExpression();
	return os;
}

int main() {

	Add a(Add(new Constant(1.0), new Constant(4.0)));

	cout << a;

	double d = a.evaluate();

	cout << d;

	return 0;
}
